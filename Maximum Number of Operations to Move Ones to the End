ğŸ” Problem Statement (in simple words)

You are given a binary string s (which means it only contains '0' and '1').

You can repeatedly perform an operation defined as follows:

Choose an index i such that:

s[i] == '1'

and s[i + 1] == '0'

Then move that '1' to the right until:

It reaches the end of the string, or

It is just before another '1'.

You can do this operation any number of times (until no '10' pattern is left).
You need to return the maximum number of such operations that can be performed.

ğŸ’¡ Example 1
Input:  s = "1001101"
Output: 4

Let's visualize step by step ğŸ‘‡

Initial: "1001101"

Operation	Choose i	Resulting String
1	i=0 (the first '10')	"0011101"
2	i=4	"0011011"
3	i=3	"0010111"
4	i=2	"0001111"

After 4 operations, there are no '10' pairs left â€” all '1's are grouped at the end.
âœ… Answer = 4

ğŸ’¡ Example 2
Input:  s = "00111"
Output: 0


Here, there is no '10' pair (the string ends with all 1â€™s together already).
So you cannot perform any move.
âœ… Answer = 0

ğŸ§  Intuitive Understanding

Think of the string as a line of people ('1's) and empty spots ('0's).

Each '1' wants to move as far to the right as possible â€” but only by swapping with a '0' thatâ€™s directly next to it.

You keep moving the 1â€™s until:

No '1' has a '0' next to it â†’ process ends.

Youâ€™re not asked to find how many swaps total happen,
but rather how many operations (individual move actions) can occur before the string becomes â€œsortedâ€ (all 1â€™s at the right end).

âš™ï¸ Algorithm (Step-by-Step)
Step 1ï¸âƒ£ â€” Initialize

ones = 0 â†’ number of '1's seen so far.

ans = 0 â†’ total operations count.

Step 2ï¸âƒ£ â€” Traverse string left to right

For each character s[i]:

If itâ€™s '1': increment ones += 1.

If itâ€™s '0':

Check if this '0' is the last character or followed by '1'.

If yes â†’ add ones to ans.

Reason:
All '1's before this '0' will eventually â€œpassâ€ over it â€” each counts as one possible move.

Step 3ï¸âƒ£ â€” Return ans
ğŸ§® Dry Run 1 â€” "1001101"
i	s[i]	Next	ones	ans	Explanation
0	'1'	'0'	1	0	count 1
1	'0'	'0'	1	0	skip
2	'0'	'1'	1	1	add ones (1)
3	'1'	'1'	2	1	count 1
4	'1'	'0'	3	1	count 1
5	'0'	'1'	3	4	add ones (3)
6	'1'	-	4	4	done

âœ… Output = 4

ğŸ§® Dry Run 2 â€” "00111"
i	s[i]	Next	ones	ans
0	'0'	'0'	0	0
1	'0'	'1'	0	0
2	'1'	'1'	1	0
3	'1'	'1'	2	0
4	'1'	-	3	0

âœ… Output = 0

â±ï¸ Time and Space Complexity
Complexity	Explanation
O(n)	Single traversal of string
O(1)	Only a few counters used
âœ… Final Python Solution
class Solution(object):
    def maxOperations(self, s):
        """
        :type s: str
        :rtype: int
        """
        ans = 0
        ones = 0
        n = len(s)

        for i, ch in enumerate(s):
            if ch == '1':
                ones += 1
            else:  # ch == '0'
                # zero used as boundary (either end or before a '1')
                if i + 1 == n or s[i + 1] == '1':
                    ans += ones
        return ans
