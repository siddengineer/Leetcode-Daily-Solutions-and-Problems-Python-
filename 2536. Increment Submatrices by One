The optimal way is to use the 2D prefix sum trick (also called the difference matrix technique) to make all updates in O(1) per query and then compute the final matrix in O(n²).

Here’s how it works step by step:

Steps:

Initialize a difference matrix diff of size n x n with all zeros.

For each query [r1, c1, r2, c2]:

Add 1 at (r1, c1) → start of submatrix increment

Subtract 1 at (r1, c2+1) → stop increment in row (if c2+1 < n)

Subtract 1 at (r2+1, c1) → stop increment in column (if r2+1 < n)

Add 1 at (r2+1, c2+1) → adjust overlapping region (if both in bounds)

Compute the prefix sum first row-wise, then column-wise to get the final matrix.

Python Implementation:
class Solution(object):
    def rangeAddQueries(self, n, queries):
        """
        :type n: int
        :type queries: List[List[int]]
        :rtype: List[List[int]]
        """
        # Step 1: initialize difference matrix
        diff = [[0]*n for _ in range(n)]
        
        # Step 2: apply all queries
        for r1, c1, r2, c2 in queries:
            diff[r1][c1] += 1
            if c2 + 1 < n:
                diff[r1][c2 + 1] -= 1
            if r2 + 1 < n:
                diff[r2 + 1][c1] -= 1
            if r2 + 1 < n and c2 + 1 < n:
                diff[r2 + 1][c2 + 1] += 1
        
        # Step 3: row-wise prefix sum
        for i in range(n):
            for j in range(1, n):
                diff[i][j] += diff[i][j-1]
        
        # Step 4: column-wise prefix sum
        for j in range(n):
            for i in range(1, n):
                diff[i][j] += diff[i-1][j]
        
        return diff

✅ Example Run:
n = 3
queries = [[1,1,2,2],[0,0,1,1]]
sol = Solution()
print(sol.rangeAddQueries(n, queries))


Output:

[[1, 1, 0],
 [1, 2, 1],
 [0, 1, 1]]


This approach works in O(n² + Q) time instead of O(n² * Q), which is crucial for large n (up to 500) and many queries (up to 10⁴).
