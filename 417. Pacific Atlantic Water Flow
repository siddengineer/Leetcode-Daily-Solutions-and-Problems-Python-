✅ Solution (DFS Approach)
class Solution(object):
    def pacificAtlantic(self, heights):
        """
        :type heights: List[List[int]]
        :rtype: List[List[int]]
        """
        if not heights or not heights[0]:
            return []

        m, n = len(heights), len(heights[0])

        pacific = set()
        atlantic = set()

        directions = [(1,0), (-1,0), (0,1), (0,-1)]

        # DFS function to mark reachable cells
        def dfs(r, c, visited, prev_height):
            # Out of bounds or height restriction
            if (r < 0 or c < 0 or r >= m or c >= n or 
                (r, c) in visited or heights[r][c] < prev_height):
                return

            visited.add((r, c))
            for dr, dc in directions:
                dfs(r + dr, c + dc, visited, heights[r][c])

        # Pacific Ocean → top and left edges
        for c in range(n):
            dfs(0, c, pacific, heights[0][c])  # Top row
            dfs(m - 1, c, atlantic, heights[m - 1][c])  # Bottom row

        # Pacific Ocean → left and Atlantic → right edges
        for r in range(m):
            dfs(r, 0, pacific, heights[r][0])  # Left column
            dfs(r, n - 1, atlantic, heights[r][n - 1])  # Right column

        # Intersection → cells reachable by both oceans
        result = list(pacific & atlantic)
        return result

🧠 Concept Explanation

Key Idea:

Instead of checking every cell if it can reach both oceans (slow),
we start DFS from the oceans and mark cells that can reach them.

If a cell can be reached from both oceans, it’s part of the result.

Pacific Ocean touches:

Top row and Left column

Atlantic Ocean touches:

Bottom row and Right column

DFS Traversal:
From each ocean border, move to neighboring cells that have equal or higher height
(since water can flow from high → low, reverse thinking is used here).

Final Step:
Return cells that are in both Pacific and Atlantic reachable sets.

🧩 Example

Input:

heights = [
  [1,2,2,3,5],
  [3,2,3,4,4],
  [2,4,5,3,1],
  [6,7,1,4,5],
  [5,1,1,2,4]
]


Output:

[[4,0],[3,0],[3,1],[2,2],[1,3],[1,4],[0,4]]

⚙️ Time & Space Complexity

Time: O(m * n) — each cell visited at most twice (once for each ocean).

Space: O(m * n) — recursion stack + visited sets.

